[{"content":"「迷惑をかけないようにしなさい」\nではなく、\n「迷惑は多少はかけるものだから、他人からの迷惑は許してあげなさい」\nと考えて行動するのが正解で、ずっとハッピーな生活ができるような気がする。\n生活でも仕事でも、「人に迷惑をかけるな」とは、良く言われることだ。特に日本人は小さい頃からそう言われて育てられる。\n今の若い子達もそうで、大学生くらいの子が大人に混じって一緒に活動する音楽バンドでの彼らの言動を見ていると、必要以上に気を使ったり萎縮したりする言動が、目立つ。\n人間が生きて行動している以上、「人に迷惑をかけない」って、絶対に無理だと思う。 もちろん、法を犯したり常識に反した結果の迷惑は、それは絶対にダメ。普通に過ごしている範囲で「他人が迷惑と感じるような行為」のこと、ね。\nオフィスで仕事の会話をしていたとしよう。当事者は真剣だとしても、関係ない周囲の人々にとっては「うるさい」と感じるかもしれない。じゃ静かに会話するか。それとも周囲がそれを許容してあげるか。\n「迷惑は多少はかけるものだから、仕方ない」\n「その代わり、他人からの迷惑は許す」\nこう考えた方が、ずっと楽なはずだ。\nよくよく考えたら、俺はそうやって過ごしてきたように思う。\n確かに、自分の諸々の言動で、周囲が迷惑に感じたことは、あるだろう。実際にそう言われたことも、ある。\nじゃ、そういう奴らが、人に迷惑を決してかけない聖人君子か？というと、全然違う。他人を不快にさせるくらいのことは、絶対にどこかで、やっているはずだ。\nなら、お互いに許してあげれば腹も立たないし、のびのびと思うことができるし、変な気遣いもいらないし。\n","date":"2023-10-17T19:10:39+09:00","permalink":"https://rochefort8.github.io/p/%E8%BF%B7%E6%83%91%E3%81%AB%E5%AF%BE%E3%81%99%E3%82%8B%E8%80%83%E3%81%88%E6%96%B9/","title":"「迷惑」に対する考え方"},{"content":"会社のセキュリティゲートでなぜか引っかかった。それを見た知り合いが\n「人相悪いからセキュリティに引っ掛かった」\nだと。もちろん冗談だけども。\n出た。久しぶりのこの反応。\nオレは確かに、人相は良くない。スキンヘッド。そして目つきも鋭く、近寄りがたい雰囲気は、確かに、ある。\nそのせいで、これまで何度か（何度も）警察官に職務質問をされて不愉快な思いをしてきた。\nいつだったか、品川駅。スリと置き引きの警戒で警察官がいっぱい、ウロウロしている。ちょっと急足で出社していたら声をかけられた。\n「ちょっと、いいですか」\n良くないわ、と言いたいが、何も悪いことしてないので快く受け入れたら、なんでも財布のスリの警戒中だ、とのこと。\nで、その時たまたま財布を二つ持っていたんだけど、それを見た警官、\n「なんで二つも持ってるんですか？」とかなり強い口調。もう完全に疑いモード。\n二つもとうが三つもとうが俺の勝手やろ\nと思いながらも、理由を説明して、財布の中身をほぼ完璧に言ったら納得しては、くれたけど、そもそも声をかけられたこと、そして財布が二つあって疑われたことは、めっちゃ不愉快。\nで、もっと不愉快なのは、この話を知り合いにしたら、ほぼ全員が、\n「お前が悪い」「そりゃ仕方ない」\nと、俺に非のあるような反応。\nなんでやねん。\n警察官も、「いかにも問題ありそうな人相」をしている人物に声をかけがち、と言った奴がいた。まぁ仕事なので仕方ないが、納得は、出来んな（笑）\n","date":"2023-10-16T15:37:34+09:00","permalink":"https://rochefort8.github.io/p/%E4%BA%BA%E3%81%AF%E8%A6%8B%E3%81%9F%E7%9B%AE%E3%81%8C100/","title":"人は見た目が100%?"},{"content":"要約 「形式的手法」は、数理論理学に基づく科学的な裏付けをもとにソフトウェア開発を行う手法である 「形式的手法」は難解なものだが、高品質を達成するには必要なものである 仕様書を最初は「自然言語」で書き、その後形式的手法を用いて書いてみることにより、仕様に潜む問題の発見に役立つかも知れない、といった使い方が効率的である 解説 「形式的手法って何？」という人がほとんどだろう。定義は以下のようなものらしい。\n1 形式手法は、システム、特に、ソフトウェアの開発法であって、数理論理学に基づく科学的な裏付けを持つ。明確で厳密な意味を持つ言語を用いて設計対象を表現することにより、設計記述の正しさを系統的に示すことが可能になる。したがって、開発したシステム、あるいは、ソフトウェアが高い信頼性を持つことを保証することができる。 難しいことを言うなぁ。おそらく「学術的手法」「論理的手法」といった方がピンとくるかも知れない。 ソフトウェアの開発の一つ一つの工程において、曖昧さを排除して間違いが起きる可能性が限りなく少ない言語や環境を使って、論理的に正しく開発進めることによって、結果出来上がる成果物の品質は必然と高くなる、と考えていいかも知れない。\nこれは、「論理的手法」vs「実践的手法」に結果帰着する話で、研究者 vs 現場　といった図式にも近いかも知れない。\nあんまりこの手法のことを考えたり経験があったりしたわけではないので、直感的な個人の感想になる。\n今の時代のソフトウェア開発は、「形式的手法」「実践的手法」に重きを置いているんじゃなかろうか。 それは、アジャイル開発の定着、CI/CDといったツールの発達で、「間違っても速やかに発見できて修正しやすい環境が整っている」からであり、それなら、考えて論理的にアプローチするよりも、開発-\u0026gt;修正を何度も繰り返した方が結果、高い品質を得られる、と言う考えで動いているように思う。\n形式手法はなぜ流行っていないのか\nゼロから学んだ形式手法\n形式手法の実践ポータル\nこの辺りが参考情報。 多くの実践例があるが、どれも「ちょっとした失敗でさえ許されない」重厚長大なシステムばっかりのようだ。アジャイルではなくウォーターフォール型の開発で進めていそうな、このような分野なら形式的手法は役立つかもしれない。\n","date":"2023-10-15T00:00:00Z","permalink":"https://rochefort8.github.io/p/%E3%82%BD%E3%83%95%E3%83%88%E3%82%A6%E3%82%A7%E3%82%A2%E9%96%8B%E7%99%BA201%E3%81%AE%E9%89%84%E5%89%87-%E5%8E%9F%E7%90%8628/","title":"ソフトウェア開発201の鉄則 原理28"},{"content":"ソフトウェア開発のバイブルと言える名著「ソフトウェア開発　２０１の鉄則」。30年以上のソフトウェア工学の知見をもとに出版。そして、その後著しく進化した現代でも全く色あせないそれぞれの教訓を、現代のソフトウェア開発のトレンドに照らし合わせながら「４行で」言い表してみることにする。\n","date":"2023-10-15T07:28:21+09:00","permalink":"https://rochefort8.github.io/p/%E3%82%BD%E3%83%95%E3%83%88%E3%82%A6%E3%82%A7%E3%82%A2%E9%96%8B%E7%99%BA-201%E3%81%AE%E9%89%84%E5%89%87%E3%81%AE%E5%90%84%E9%89%84%E5%89%87%E3%82%92%EF%BC%94%E8%A1%8C%E3%81%A7%E3%81%BE%E3%81%A8%E3%82%81%E3%81%A6%E3%81%BF%E3%82%8B/","title":"「ソフトウェア開発 201の鉄則」の各鉄則を４行でまとめてみる"},{"content":"「三日坊主選手権」があったら全国大会に出場できる自信あります。それくらい飽きっぽくてブログは何度も初めては放置して、、の繰り返しでしたが、 毎日何か思うことがあるので、それを文章化してみようかな、と。\nサイト構築にはみーとみの個人ブログの情報が大変役立ちました。ありがとうございます！\n","date":"2023-10-15T07:12:51+09:00","permalink":"https://rochefort8.github.io/p/%E3%83%96%E3%83%AD%E3%82%B0%E3%81%AF%E3%81%98%E3%82%81%E3%81%A6%E3%81%BF%E3%81%BE%E3%81%97%E3%81%9F/","title":"ブログはじめてみました"},{"content":"要旨 構造化プログラミングは、もともとは、プログラムの正しさをカンタンに確かめることができるように提唱されたものだ 今では、そのときに定義された条件分岐やサブルーチンなどを使うこと自体が構造化プログラミングと呼ぶようになった プログラムをわかりやすくする、という点で、構造化プログラミングは必要だ しかし、それは「高品質なプログラミング」の一部の要素であって、十分条件ではない 解説 1969 年に、ソフトウェア工学ではしばしば名前の出てくるDikstra さんが提唱したもの。\n元の目的は、プログラムの正確さをより簡単に測るための見やすさ向上、なんですね（知らなかった）。\nそして今では、プログラミングの基本要素となっている。ここに詳しい。\nこの原理で言っているのは、その、構造化プログラミングができたからといって、それが高品質なソフトウェアとては言えない、ということ。\nそりゃそうですね。よくある、\n必要条件だが、十分条件ではない\nという事項の一つ。\n","date":"2020-05-27T00:00:00Z","permalink":"https://rochefort8.github.io/p/%E3%82%BD%E3%83%95%E3%83%88%E3%82%A6%E3%82%A7%E3%82%A2%E9%96%8B%E7%99%BA201%E3%81%AE%E9%89%84%E5%89%87-%E5%8E%9F%E7%90%86100/","title":"ソフトウェア開発201の鉄則 原理100"},{"content":"要旨 デバッグやリグレッションテスト、確認のための単体テストといったもの以外の、本格的なテストをソフトウェア開発者は自分で行ってはならない テストというのは、バグが見つかって欲しくないと願う開発者に対し、バグを見つける、という行為なので、自分で行ったら正しくできるはずもないからだ そして、テスト担当者は、発見したバグを皆の前にさらして、開発者の面子を潰すようなことをしてはならない テスティングというのは、バグがでないことを期待する開発者に対し、精神的に追い打ちをかけるような仕事であることを開発者もテスターも認識しよう 解説 こう書いてあると、そっか、自分じゃやっちゃいけないのか、と思うだろう。\n自分でやるべきテストも、ある。それは、自分が設計・実装した機能が基本たたしく動作するかを確認するための単体テスト、それと、バグを修正した時、本当にちゃんと修正されているか、別のバグを発生させていないか、を確認するリグレッションテスト。\nこれは、ソフトウェア開発者が「自分が正しい仕事ができたのか」を確認するためのものなのだから、それは、自分でやろう。\nそれ以降の本格的なテスティング、ストレステストとか統合テストとか、ロングランとか。\nテスティングというのは、バグがないことを示すためにやるのでは、「ない」。\n全く逆で、「バグを見つけるために」やるものである。\n一方で、ソフトウェア開発者は、決して、自分が開発したものにバグがあることを望んだりは、しないだろう。\nそのような、自分が作ったものに対して、出てくることを望まないバグを見つける。それがテスティング。\n自分でできるわけが、ない。\nどうしても、自分でやると、甘〜〜くなるだろう。本格的にテストしているようで、どうしても特定の優しい状況を作り出して実行していることが往々にある。\n十分確認した、と自信満々で持ち込んで、テスターに一撃でバグを見つけられた、という経験は、誰しもお持ちだろう。\n「バグがない」というのは、開発者にとって、成果を出した証。\n「バグを見つけた」というのは、テスターにとって、成果を出した証。\nお互いの仕事を尊重して、仲良くやりましょう。\n","date":"2020-05-24T00:00:00Z","permalink":"https://rochefort8.github.io/p/%E3%82%BD%E3%83%95%E3%83%88%E3%82%A6%E3%82%A7%E3%82%A2%E9%96%8B%E7%99%BA201%E3%81%AE%E9%89%84%E5%89%87-%E5%8E%9F%E7%90%86109/","title":"ソフトウェア開発201の鉄則 原理109"},{"content":"要旨 ソフトウェアで最もコストがかかる工程は、「保守」である なので、保守が容易となるように設計をせよ その方法に、一般的なものはない 例えば、基本構造の選択時に、アルゴリズムやコードの選択よりも保守性を重視する、といったことが挙げられる 解説 ソフトウェア「以外の」製品、要するにハードウェアは、設計後最も費用がかかるのは、「生産」。なので、ハードウェア設計の際に一番考慮しなくてはならないのは、生産性。\nソフトウェアの場合、生産にはほとんど費用がかからない場合が多い。その代わり、保守、運用に費用がかかる。なので、ソフトウェア設計の際に一番考慮しなくてはならないのは、保守・運用。\n生存期間が短いプロトタイプはともかく、製品に組み込まれるソフトウェア、サービスを支えるソフトウェアは、出荷・リリースしてからが本番が始まる。\n売れる、流行るものほど、ここから先の保守・運用が長い。一つのプロジェクトでトータルでかかった費用のうち、９割以上が保守・運用というデータもある。\n設計・実装のフェーズで保守・運用のことを最大限に考慮しなくてはならないのは、当然のことなのだ。\n「保守・運用のための設計」は、一意ではない。保守を容易にするには、総合て的なアプローチが必要だ。\n最適な基本構造の選択、アルゴリズム、データ構造の選択。\n「コーディングの原理」にも上がっている鉄則「読みやすい・わかりやすいコード作成」。\nドキュメントをきちんと残すこと。\nこういった行動の集合体が、保守性を容易にするアプローチだろう。\n","date":"2020-05-23T00:00:00Z","permalink":"https://rochefort8.github.io/p/%E3%82%BD%E3%83%95%E3%83%88%E3%82%A6%E3%82%A7%E3%82%A2%E9%96%8B%E7%99%BA201%E3%81%AE%E9%89%84%E5%89%87-%E5%8E%9F%E7%90%8675/","title":"ソフトウェア開発201の鉄則 原理75"},{"content":"","date":"2020-05-22T00:00:00Z","permalink":"https://rochefort8.github.io/p/%E3%82%BD%E3%83%95%E3%83%88%E3%82%A6%E3%82%A7%E3%82%A2%E9%96%8B%E7%99%BA201%E3%81%AE%E9%89%84%E5%89%87-%E5%8E%9F%E7%90%86126/","title":"ソフトウェア開発201の鉄則 原理126"},{"content":"","date":"2020-05-20T00:00:00Z","permalink":"https://rochefort8.github.io/p/%E3%82%BD%E3%83%95%E3%83%88%E3%82%A6%E3%82%A7%E3%82%A2%E9%96%8B%E7%99%BA201%E3%81%AE%E9%89%84%E5%89%87-%E5%8E%9F%E7%90%8676/","title":"ソフトウェア開発201の鉄則 原理76"},{"content":"","date":"2020-05-17T00:00:00Z","permalink":"https://rochefort8.github.io/p/%E3%82%BD%E3%83%95%E3%83%88%E3%82%A6%E3%82%A7%E3%82%A2%E9%96%8B%E7%99%BA201%E3%81%AE%E9%89%84%E5%89%87-%E5%8E%9F%E7%90%86147/","title":"ソフトウェア開発201の鉄則 原理147"},{"content":"","date":"2020-05-16T00:00:00Z","permalink":"https://rochefort8.github.io/p/%E3%82%BD%E3%83%95%E3%83%88%E3%82%A6%E3%82%A7%E3%82%A2%E9%96%8B%E7%99%BA201%E3%81%AE%E9%89%84%E5%89%87-%E5%8E%9F%E7%90%86114/","title":"ソフトウェア開発201の鉄則 原理114"},{"content":"","date":"2020-05-15T00:00:00Z","permalink":"https://rochefort8.github.io/p/%E3%82%BD%E3%83%95%E3%83%88%E3%82%A6%E3%82%A7%E3%82%A2%E9%96%8B%E7%99%BA201%E3%81%AE%E9%89%84%E5%89%87-%E5%8E%9F%E7%90%86125/","title":"ソフトウェア開発201の鉄則 原理125"},{"content":"","date":"2020-05-14T00:00:00Z","permalink":"https://rochefort8.github.io/p/%E3%82%BD%E3%83%95%E3%83%88%E3%82%A6%E3%82%A7%E3%82%A2%E9%96%8B%E7%99%BA201%E3%81%AE%E9%89%84%E5%89%87-%E5%8E%9F%E7%90%86185/","title":"ソフトウェア開発201の鉄則 原理185"},{"content":"","date":"2020-05-13T00:00:00Z","permalink":"https://rochefort8.github.io/p/%E3%82%BD%E3%83%95%E3%83%88%E3%82%A6%E3%82%A7%E3%82%A2%E9%96%8B%E7%99%BA201%E3%81%AE%E9%89%84%E5%89%87-%E5%8E%9F%E7%90%86138/","title":"ソフトウェア開発201の鉄則 原理138"},{"content":"","date":"2020-05-12T00:00:00Z","permalink":"https://rochefort8.github.io/p/%E3%82%BD%E3%83%95%E3%83%88%E3%82%A6%E3%82%A7%E3%82%A2%E9%96%8B%E7%99%BA201%E3%81%AE%E9%89%84%E5%89%87-%E5%8E%9F%E7%90%86111/","title":"ソフトウェア開発201の鉄則 原理111"},{"content":"","date":"2020-05-10T00:00:00Z","permalink":"https://rochefort8.github.io/p/%E3%82%BD%E3%83%95%E3%83%88%E3%82%A6%E3%82%A7%E3%82%A2%E9%96%8B%E7%99%BA201%E3%81%AE%E9%89%84%E5%89%87-%E5%8E%9F%E7%90%86129/","title":"ソフトウェア開発201の鉄則 原理129"},{"content":"","date":"2020-05-09T00:00:00Z","permalink":"https://rochefort8.github.io/p/%E3%82%BD%E3%83%95%E3%83%88%E3%82%A6%E3%82%A7%E3%82%A2%E9%96%8B%E7%99%BA201%E3%81%AE%E9%89%84%E5%89%87-%E5%8E%9F%E7%90%86128/","title":"ソフトウェア開発201の鉄則 原理128"},{"content":"","date":"2020-05-08T00:00:00Z","permalink":"https://rochefort8.github.io/p/%E3%82%BD%E3%83%95%E3%83%88%E3%82%A6%E3%82%A7%E3%82%A2%E9%96%8B%E7%99%BA201%E3%81%AE%E9%89%84%E5%89%87-%E5%8E%9F%E7%90%8692/","title":"ソフトウェア開発201の鉄則 原理92"},{"content":"","date":"2020-05-06T00:00:00Z","permalink":"https://rochefort8.github.io/p/%E3%82%BD%E3%83%95%E3%83%88%E3%82%A6%E3%82%A7%E3%82%A2%E9%96%8B%E7%99%BA201%E3%81%AE%E9%89%84%E5%89%87-%E5%8E%9F%E7%90%86107/","title":"ソフトウェア開発201の鉄則 原理107"},{"content":"","date":"2020-05-05T00:00:00Z","permalink":"https://rochefort8.github.io/p/%E3%82%BD%E3%83%95%E3%83%88%E3%82%A6%E3%82%A7%E3%82%A2%E9%96%8B%E7%99%BA201%E3%81%AE%E9%89%84%E5%89%87-%E5%8E%9F%E7%90%8694/","title":"ソフトウェア開発201の鉄則 原理94"},{"content":"","date":"2020-05-04T00:00:00Z","permalink":"https://rochefort8.github.io/p/%E3%82%BD%E3%83%95%E3%83%88%E3%82%A6%E3%82%A7%E3%82%A2%E9%96%8B%E7%99%BA201%E3%81%AE%E9%89%84%E5%89%87-%E5%8E%9F%E7%90%8652/","title":"ソフトウェア開発201の鉄則 原理52"},{"content":"","date":"2020-05-02T00:00:00Z","permalink":"https://rochefort8.github.io/p/%E3%82%BD%E3%83%95%E3%83%88%E3%82%A6%E3%82%A7%E3%82%A2%E9%96%8B%E7%99%BA201%E3%81%AE%E9%89%84%E5%89%87-%E5%8E%9F%E7%90%8665/","title":"ソフトウェア開発201の鉄則 原理65"},{"content":"","date":"2020-05-01T00:00:00Z","permalink":"https://rochefort8.github.io/p/%E3%82%BD%E3%83%95%E3%83%88%E3%82%A6%E3%82%A7%E3%82%A2%E9%96%8B%E7%99%BA201%E3%81%AE%E9%89%84%E5%89%87-%E5%8E%9F%E7%90%86134/","title":"ソフトウェア開発201の鉄則 原理134"},{"content":"","date":"2020-04-30T00:00:00Z","permalink":"https://rochefort8.github.io/p/%E3%82%BD%E3%83%95%E3%83%88%E3%82%A6%E3%82%A7%E3%82%A2%E9%96%8B%E7%99%BA201%E3%81%AE%E9%89%84%E5%89%87-%E5%8E%9F%E7%90%8651/","title":"ソフトウェア開発201の鉄則 原理51"},{"content":"","date":"2020-04-29T00:00:00Z","permalink":"https://rochefort8.github.io/p/%E3%82%BD%E3%83%95%E3%83%88%E3%82%A6%E3%82%A7%E3%82%A2%E9%96%8B%E7%99%BA201%E3%81%AE%E9%89%84%E5%89%87-%E5%8E%9F%E7%90%8695/","title":"ソフトウェア開発201の鉄則 原理95"},{"content":"","date":"2020-04-28T00:00:00Z","permalink":"https://rochefort8.github.io/p/%E3%82%BD%E3%83%95%E3%83%88%E3%82%A6%E3%82%A7%E3%82%A2%E9%96%8B%E7%99%BA201%E3%81%AE%E9%89%84%E5%89%87-%E5%8E%9F%E7%90%8650/","title":"ソフトウェア開発201の鉄則 原理50"},{"content":"","date":"2020-04-27T00:00:00Z","permalink":"https://rochefort8.github.io/p/%E3%82%BD%E3%83%95%E3%83%88%E3%82%A6%E3%82%A7%E3%82%A2%E9%96%8B%E7%99%BA201%E3%81%AE%E9%89%84%E5%89%87-%E5%8E%9F%E7%90%86105/","title":"ソフトウェア開発201の鉄則 原理105"},{"content":"","date":"2020-04-26T00:00:00Z","permalink":"https://rochefort8.github.io/p/%E3%82%BD%E3%83%95%E3%83%88%E3%82%A6%E3%82%A7%E3%82%A2%E9%96%8B%E7%99%BA201%E3%81%AE%E9%89%84%E5%89%87-%E5%8E%9F%E7%90%8643/","title":"ソフトウェア開発201の鉄則 原理43"},{"content":"","date":"2020-04-22T00:00:00Z","permalink":"https://rochefort8.github.io/p/%E3%82%BD%E3%83%95%E3%83%88%E3%82%A6%E3%82%A7%E3%82%A2%E9%96%8B%E7%99%BA201%E3%81%AE%E9%89%84%E5%89%87-%E5%8E%9F%E7%90%8642/","title":"ソフトウェア開発201の鉄則 原理42"},{"content":"","date":"2020-04-18T00:00:00Z","permalink":"https://rochefort8.github.io/p/%E3%82%BD%E3%83%95%E3%83%88%E3%82%A6%E3%82%A7%E3%82%A2%E9%96%8B%E7%99%BA201%E3%81%AE%E9%89%84%E5%89%87-%E5%8E%9F%E7%90%86101/","title":"ソフトウェア開発201の鉄則 原理101"},{"content":"","date":"2020-04-16T00:00:00Z","permalink":"https://rochefort8.github.io/p/%E3%82%BD%E3%83%95%E3%83%88%E3%82%A6%E3%82%A7%E3%82%A2%E9%96%8B%E7%99%BA201%E3%81%AE%E9%89%84%E5%89%87-%E5%8E%9F%E7%90%8641/","title":"ソフトウェア開発201の鉄則 原理41"},{"content":"","date":"2020-04-15T00:00:00Z","permalink":"https://rochefort8.github.io/p/%E3%82%BD%E3%83%95%E3%83%88%E3%82%A6%E3%82%A7%E3%82%A2%E9%96%8B%E7%99%BA201%E3%81%AE%E9%89%84%E5%89%87-%E5%8E%9F%E7%90%8636/","title":"ソフトウェア開発201の鉄則 原理36"},{"content":"","date":"2020-04-15T00:00:00Z","permalink":"https://rochefort8.github.io/p/%E3%82%BD%E3%83%95%E3%83%88%E3%82%A6%E3%82%A7%E3%82%A2%E9%96%8B%E7%99%BA201%E3%81%AE%E9%89%84%E5%89%87-%E5%8E%9F%E7%90%8637/","title":"ソフトウェア開発201の鉄則 原理37"},{"content":"","date":"2020-04-14T00:00:00Z","permalink":"https://rochefort8.github.io/p/%E3%82%BD%E3%83%95%E3%83%88%E3%82%A6%E3%82%A7%E3%82%A2%E9%96%8B%E7%99%BA201%E3%81%AE%E9%89%84%E5%89%87-%E5%8E%9F%E7%90%8635/","title":"ソフトウェア開発201の鉄則 原理35"},{"content":"","date":"2020-04-13T00:00:00Z","permalink":"https://rochefort8.github.io/p/%E3%82%BD%E3%83%95%E3%83%88%E3%82%A6%E3%82%A7%E3%82%A2%E9%96%8B%E7%99%BA201%E3%81%AE%E9%89%84%E5%89%87-%E5%8E%9F%E7%90%8634/","title":"ソフトウェア開発201の鉄則 原理34"},{"content":"","date":"2020-04-12T00:00:00Z","permalink":"https://rochefort8.github.io/p/%E3%82%BD%E3%83%95%E3%83%88%E3%82%A6%E3%82%A7%E3%82%A2%E9%96%8B%E7%99%BA201%E3%81%AE%E9%89%84%E5%89%87-%E5%8E%9F%E7%90%8633/","title":"ソフトウェア開発201の鉄則 原理33"},{"content":"","date":"2020-04-11T00:00:00Z","permalink":"https://rochefort8.github.io/p/%E3%82%BD%E3%83%95%E3%83%88%E3%82%A6%E3%82%A7%E3%82%A2%E9%96%8B%E7%99%BA201%E3%81%AE%E9%89%84%E5%89%87-%E5%8E%9F%E7%90%8632/","title":"ソフトウェア開発201の鉄則 原理32"},{"content":"","date":"2020-04-10T00:00:00Z","permalink":"https://rochefort8.github.io/p/%E3%82%BD%E3%83%95%E3%83%88%E3%82%A6%E3%82%A7%E3%82%A2%E9%96%8B%E7%99%BA201%E3%81%AE%E9%89%84%E5%89%87-%E5%8E%9F%E7%90%8631/","title":"ソフトウェア開発201の鉄則 原理31"},{"content":"","date":"2020-04-09T00:00:00Z","permalink":"https://rochefort8.github.io/p/%E3%82%BD%E3%83%95%E3%83%88%E3%82%A6%E3%82%A7%E3%82%A2%E9%96%8B%E7%99%BA201%E3%81%AE%E9%89%84%E5%89%87-%E5%8E%9F%E7%90%8630/","title":"ソフトウェア開発201の鉄則 原理30"},{"content":"","date":"2020-04-08T00:00:00Z","permalink":"https://rochefort8.github.io/p/%E3%82%BD%E3%83%95%E3%83%88%E3%82%A6%E3%82%A7%E3%82%A2%E9%96%8B%E7%99%BA201%E3%81%AE%E9%89%84%E5%89%87-%E5%8E%9F%E7%90%8629/","title":"ソフトウェア開発201の鉄則 原理29"},{"content":"","date":"2020-04-07T00:00:00Z","permalink":"https://rochefort8.github.io/p/%E3%82%BD%E3%83%95%E3%83%88%E3%82%A6%E3%82%A7%E3%82%A2%E9%96%8B%E7%99%BA201%E3%81%AE%E9%89%84%E5%89%87-%E5%8E%9F%E7%90%86141/","title":"ソフトウェア開発201の鉄則 原理141"},{"content":"","date":"2020-04-06T00:00:00Z","permalink":"https://rochefort8.github.io/p/%E3%82%BD%E3%83%95%E3%83%88%E3%82%A6%E3%82%A7%E3%82%A2%E9%96%8B%E7%99%BA201%E3%81%AE%E9%89%84%E5%89%87-%E5%8E%9F%E7%90%8627/","title":"ソフトウェア開発201の鉄則 原理27"},{"content":"","date":"2020-04-05T00:00:00Z","permalink":"https://rochefort8.github.io/p/%E3%82%BD%E3%83%95%E3%83%88%E3%82%A6%E3%82%A7%E3%82%A2%E9%96%8B%E7%99%BA201%E3%81%AE%E9%89%84%E5%89%87-%E5%8E%9F%E7%90%8626/","title":"ソフトウェア開発201の鉄則 原理26"},{"content":"","date":"2020-04-04T00:00:00Z","permalink":"https://rochefort8.github.io/p/%E3%82%BD%E3%83%95%E3%83%88%E3%82%A6%E3%82%A7%E3%82%A2%E9%96%8B%E7%99%BA201%E3%81%AE%E9%89%84%E5%89%87-%E5%8E%9F%E7%90%8625/","title":"ソフトウェア開発201の鉄則 原理25"},{"content":"","date":"2020-04-03T00:00:00Z","permalink":"https://rochefort8.github.io/p/%E3%82%BD%E3%83%95%E3%83%88%E3%82%A6%E3%82%A7%E3%82%A2%E9%96%8B%E7%99%BA201%E3%81%AE%E9%89%84%E5%89%87-%E5%8E%9F%E7%90%8624/","title":"ソフトウェア開発201の鉄則 原理24"},{"content":"","date":"2020-04-02T00:00:00Z","permalink":"https://rochefort8.github.io/p/%E3%82%BD%E3%83%95%E3%83%88%E3%82%A6%E3%82%A7%E3%82%A2%E9%96%8B%E7%99%BA201%E3%81%AE%E9%89%84%E5%89%87-%E5%8E%9F%E7%90%86161/","title":"ソフトウェア開発201の鉄則 原理161"},{"content":"","date":"2020-04-01T00:00:00Z","permalink":"https://rochefort8.github.io/p/%E3%82%BD%E3%83%95%E3%83%88%E3%82%A6%E3%82%A7%E3%82%A2%E9%96%8B%E7%99%BA201%E3%81%AE%E9%89%84%E5%89%87-%E5%8E%9F%E7%90%8623/","title":"ソフトウェア開発201の鉄則 原理23"},{"content":"","date":"2020-03-31T00:00:00Z","permalink":"https://rochefort8.github.io/p/%E3%82%BD%E3%83%95%E3%83%88%E3%82%A6%E3%82%A7%E3%82%A2%E9%96%8B%E7%99%BA201%E3%81%AE%E9%89%84%E5%89%87-%E5%8E%9F%E7%90%8622/","title":"ソフトウェア開発201の鉄則 原理22"},{"content":"","date":"2020-03-30T00:00:00Z","permalink":"https://rochefort8.github.io/p/%E3%82%BD%E3%83%95%E3%83%88%E3%82%A6%E3%82%A7%E3%82%A2%E9%96%8B%E7%99%BA201%E3%81%AE%E9%89%84%E5%89%87-%E5%8E%9F%E7%90%8621/","title":"ソフトウェア開発201の鉄則 原理21"},{"content":"","date":"2020-03-29T00:00:00Z","permalink":"https://rochefort8.github.io/p/%E3%82%BD%E3%83%95%E3%83%88%E3%82%A6%E3%82%A7%E3%82%A2%E9%96%8B%E7%99%BA201%E3%81%AE%E9%89%84%E5%89%87-%E5%8E%9F%E7%90%8620/","title":"ソフトウェア開発201の鉄則 原理20"},{"content":"","date":"2020-03-28T00:00:00Z","permalink":"https://rochefort8.github.io/p/%E3%82%BD%E3%83%95%E3%83%88%E3%82%A6%E3%82%A7%E3%82%A2%E9%96%8B%E7%99%BA201%E3%81%AE%E9%89%84%E5%89%87-%E5%8E%9F%E7%90%8619/","title":"ソフトウェア開発201の鉄則 原理19"},{"content":"","date":"2020-03-28T00:00:00Z","permalink":"https://rochefort8.github.io/p/%E3%82%BD%E3%83%95%E3%83%88%E3%82%A6%E3%82%A7%E3%82%A2%E9%96%8B%E7%99%BA201%E3%81%AE%E9%89%84%E5%89%87-%E5%8E%9F%E7%90%86199/","title":"ソフトウェア開発201の鉄則 原理199"},{"content":"","date":"2020-03-27T00:00:00Z","permalink":"https://rochefort8.github.io/p/%E3%82%BD%E3%83%95%E3%83%88%E3%82%A6%E3%82%A7%E3%82%A2%E9%96%8B%E7%99%BA201%E3%81%AE%E9%89%84%E5%89%87-%E5%8E%9F%E7%90%86139/","title":"ソフトウェア開発201の鉄則 原理139"},{"content":"","date":"2020-03-27T00:00:00Z","permalink":"https://rochefort8.github.io/p/%E3%82%BD%E3%83%95%E3%83%88%E3%82%A6%E3%82%A7%E3%82%A2%E9%96%8B%E7%99%BA201%E3%81%AE%E9%89%84%E5%89%87-%E5%8E%9F%E7%90%8618/","title":"ソフトウェア開発201の鉄則 原理18"},{"content":"","date":"2020-03-26T00:00:00Z","permalink":"https://rochefort8.github.io/p/%E3%82%BD%E3%83%95%E3%83%88%E3%82%A6%E3%82%A7%E3%82%A2%E9%96%8B%E7%99%BA201%E3%81%AE%E9%89%84%E5%89%87-%E5%8E%9F%E7%90%8617/","title":"ソフトウェア開発201の鉄則 原理17"},{"content":"","date":"2020-03-25T00:00:00Z","permalink":"https://rochefort8.github.io/p/%E3%82%BD%E3%83%95%E3%83%88%E3%82%A6%E3%82%A7%E3%82%A2%E9%96%8B%E7%99%BA201%E3%81%AE%E9%89%84%E5%89%87-%E5%8E%9F%E7%90%8616/","title":"ソフトウェア開発201の鉄則 原理16"},{"content":"要旨 高機能・高性能であればあるほど、顧客はさらにもっと多い・高いものを求めたがるものだ リリース後、顧客からたくさんの、そのような要求があることを理解し、管理、技術、プロセスといった面で備えよ ドキュメントに変更履歴を記載する、構成管理システムを導入する、ソフトウェアの設計は変更に強くしておく、といったアプローチが挙げられる 解説 こ「高機能・高性能であればあるほど」なんですね。たしかに。顧客は、\n「今知っているレベルよりより高いものを常に」かと思っていました。じゃ、あまり機能や性能が立派でないときは、求めないんですかね。あきらめるのかなｗ\nそう、頑張って立派な成果を出せば出すほど、いい意味で欲がでるんでしょうね、お客さんは、もっといいものを求めるように、なります。開発者にとっては、嬉しいような、つらいような。\nそれより、大事なことは。\n顧客というものはそういうものなので、それを受け入れて、最初からソフトウェアの設計・実装、プロセス、管理のあらゆる面について、変更や追加に対して柔軟にしておきなさい、ということ。\n201の鉄則中にも、このための原理がいくつもある。「システムは漸進的に成長させよ」「ソフトウェアは変化し続ける」、、などなど。\n","date":"2020-03-24T00:00:00Z","permalink":"https://rochefort8.github.io/p/%E3%82%BD%E3%83%95%E3%83%88%E3%82%A6%E3%82%A7%E3%82%A2%E9%96%8B%E7%99%BA201%E3%81%AE%E9%89%84%E5%89%87-%E5%8E%9F%E7%90%8615/","title":"ソフトウェア開発201の鉄則 原理15"},{"content":"要旨 ソフトウェア開発のリスク軽減に最も効果的な方法は、「少しずづ開発を進める」ことだ 限られた最小限の機能から始め、それを少しづつ成長させて大きな機能のものとする方法である 利点は、各開発段階でのリスクが抑えられること、こまめにユーザのフィードバックが得られること、短所は、元の設計がマズいときは完全な再設計が必要となること この短所を減らすための手法が「使い捨てプロトタイプ」である 解説 「斬新的（ざんしんてき）」は、Incremental の日本語訳。原本には\u0026quot;Grow incrementally\u0026quot; とある。今では「インクリメンタル開発」という言葉が定着している。\nそして、「最初は小さいところから」は、\u0026ldquo;Start small\u0026rdquo; . こちらも、ビジネス用語だが「スモールスタート」という言葉が、すでに馴染みのあるものになっている。\n小さなことを積み重ねて、大きな成果につなげる。世の中一般的になんでも、これが大事なのは自明。\nソフトウェアは、凄いスピードで成長している世界だ。そんな中では、このようなインクリメンタルな開発で柔軟に対応していくことが、ますます必要となってくる。小さなことから始めて、小さなことを積み重ねる。現代のソフトウェア開発により当てはまることだろう。\n","date":"2020-03-23T00:00:00Z","permalink":"https://rochefort8.github.io/p/%E3%82%BD%E3%83%95%E3%83%88%E3%82%A6%E3%82%A7%E3%82%A2%E9%96%8B%E7%99%BA201%E3%81%AE%E9%89%84%E5%89%87-%E5%8E%9F%E7%90%8614/","title":"ソフトウェア開発201の鉄則 原理14"},{"content":"","date":"2020-03-23T00:00:00Z","permalink":"https://rochefort8.github.io/p/%E3%82%BD%E3%83%95%E3%83%88%E3%82%A6%E3%82%A7%E3%82%A2%E9%96%8B%E7%99%BA201%E3%81%AE%E9%89%84%E5%89%87-%E5%8E%9F%E7%90%8640/","title":"ソフトウェア開発201の鉄則 原理40"},{"content":"要旨 使い捨て型のプロトタイプは素早く作れ 簡単な要求仕様書さえあれば十分、品質や体裁は気にしなくていい 言語は何を使ってもいい、本番との言語の差分について気にしなくていい 解説 とにかく「スピード重視」ということ。\n言語は何でもいい、とあるが、もっというと、プログラミングでなくてもいい。モバイルアプリのUX なら、PowerPointで書いたポンチ絵とか、動画でもいいかもしれない。\n作る予定のスマホアプリの機能を紹介するのに、Android で画面遷移だけ、画面もネットで拾ってきて、だ〜いたいこんな機能、というのを見せるアプリを一時間くらいで作ったことがある。やりたいことは伝わったし、ウケたし、目的はそれで十分達成。そしてもちろん、捨てた。\n使い捨て型のプロトタイプなら、それで、いいのだ。\n","date":"2020-03-22T00:00:00Z","permalink":"https://rochefort8.github.io/p/%E3%82%BD%E3%83%95%E3%83%88%E3%82%A6%E3%82%A7%E3%82%A2%E9%96%8B%E7%99%BA201%E3%81%AE%E9%89%84%E5%89%87-%E5%8E%9F%E7%90%8613/","title":"ソフトウェア開発201の鉄則 原理13"},{"content":"","date":"2020-03-22T00:00:00Z","permalink":"https://rochefort8.github.io/p/%E3%82%BD%E3%83%95%E3%83%88%E3%82%A6%E3%82%A7%E3%82%A2%E9%96%8B%E7%99%BA201%E3%81%AE%E9%89%84%E5%89%87-%E5%8E%9F%E7%90%86173/","title":"ソフトウェア開発201の鉄則 原理173"},{"content":"要旨 使い捨て型のプロトタイプには、よく理解されていない、要件が不明確な機能「のみ」を組み込め 進化型のプロトタイプには、最もよく理解されている、最も明確な機能を組み込め いずれも、それぞれの型の目的に沿った機能を組み込むことにより、ユーザからの適切なフィードバックが得られる。 解説 原理11「適切な型のプロトタイプを開発せよ」の続き。\nプロトタイプは、使い捨てであろうが、進化型であろうが、目的は、「ユーザのフードバックを」「素早く」得るために作るものである。\nこの２つ目の「素早く」を念頭に置いておこう。余計なことは、やらない。得たい情報、見せたいものだけのために、作るものだ。\n","date":"2020-03-21T00:00:00Z","permalink":"https://rochefort8.github.io/p/%E3%82%BD%E3%83%95%E3%83%88%E3%82%A6%E3%82%A7%E3%82%A2%E9%96%8B%E7%99%BA201%E3%81%AE%E9%89%84%E5%89%87-%E5%8E%9F%E7%90%8612/","title":"ソフトウェア開発201の鉄則 原理12"},{"content":"","date":"2020-03-21T00:00:00Z","permalink":"https://rochefort8.github.io/p/%E3%82%BD%E3%83%95%E3%83%88%E3%82%A6%E3%82%A7%E3%82%A2%E9%96%8B%E7%99%BA201%E3%81%AE%E9%89%84%E5%89%87-%E5%8E%9F%E7%90%8684/","title":"ソフトウェア開発201の鉄則 原理84"},{"content":"要旨 プロトタイプは「使い捨て型」と「進化型」の２つの種類がある 「使い捨て型」は、フィードバックを得るために素早く、重要な事項が不明確な時に作られるものである 「進化型」は、品質もそれなりに確保され、フィードバックを得た後は修正をされて継続的に進化するものであり、重要な事項は明確だが他の多くのものが不明確な時に作られるものである ほとんどの事項が不明確な時は、まず使い捨て型、その後進化型のプロトタイプを作ると良い 解説 「要旨」の通り。あえていうなら、\n「使い捨て型」を作る時は、とにかく素早く作ることを優先させよう。エンジニアは、「ちゃんと」作りたがる性の方が多い。つい、それなりにきちんと動くものにするのに時間をかけがちだが、「動いて、人に見せられれば良い」くらいに割り切った方がいい。３回に一回くらいしかきちんと動かない代物でも、伝わればフィードバックは得られて所望の目的は充分達するのだから。\n","date":"2020-03-20T00:00:00Z","permalink":"https://rochefort8.github.io/p/%E3%82%BD%E3%83%95%E3%83%88%E3%82%A6%E3%82%A7%E3%82%A2%E9%96%8B%E7%99%BA201%E3%81%AE%E9%89%84%E5%89%87-%E5%8E%9F%E7%90%8611/","title":"ソフトウェア開発201の鉄則 原理11"},{"content":"","date":"2020-03-20T00:00:00Z","permalink":"https://rochefort8.github.io/p/%E3%82%BD%E3%83%95%E3%83%88%E3%82%A6%E3%82%A7%E3%82%A2%E9%96%8B%E7%99%BA201%E3%81%AE%E9%89%84%E5%89%87-%E5%8E%9F%E7%90%86137/","title":"ソフトウェア開発201の鉄則 原理137"},{"content":"要旨 アルゴリズム、設計など、なんらかの「新規項目」があるソフトウェアは、最初からうまくいかないことが常である 最初のソフトウェアは、その新規項目の設計や方向性が正しいかを検討するためのものであるべきだ そして、全体の25% をこのような新規項目の妥当性検討に使うべきである 具体的な施策としては、「プロトタイプを作る」「リリース後も定期的にアップデートできるようにしておく」と言ったことが挙げられる 解説 新しいものは、最初からはうまくいかない。これは、どの分野でも、何でもそう。じゃどうしたらいいか。\n新しいものは、事前に充分な検討を重ねよう、ではなく、\n上手くいくまでに何度か作り直そう 作って、妥当性や課題などの情報を得たら捨てて、それを活かして次より良いのを作ろう こういうアプローチがアリ、なのがソフトウェア開発らしい、と言ってもいいかもしれない。\nなぜこの方法がソフトウェア開発では有効なのか。いくつか考えられることを挙げてみる。\n作って、見せて、触ってみて初めて気づくことが多い 作らずに、事前に大事なことが洗い出せれば、それに越したことはない。ただ、ソフトウェアは一般的にはとても複雑。そして大抵の場合は目標が不明確。なので、プロトタイプのような方法が有効たり得る。\n使い捨てのコストが安い これに尽きるんじゃないだろうか。\n仮に、今新しい航空機を作ってるとしよう。問題点を明らかにするために、じゃ作って飛ばしてみようか、とは、絶対にならない。作って、捨てるには莫大な費用がかかる。そして、問題点がわかったら、その時は大変なことになる。なので、事前に問題点を洗い出す、作る前にシミュレーションを繰り返す、というアプローチになる。\nソフトウェアは、これと比べれば、作るのも容易、そして作り直すのも容易。医療用のシステムのような人命に関わるものもあるが、そうでない限り、大事にはならない。なので、妥当性とか課題とか、次に活かせそうな情報が取得して、破棄することに対するコストよりも、獲得した情報の価値が高ければ良い。\nDocker のような仮想環境だと、実行環境からして手軽に作れる。コンピュータ（マシン）を手軽に作っては捨てることができる、ということだ。\n基本、ソフトウェア開発は、「作っては捨てる」を「カンタンに安く」実行できる方向に進化しているように思う。\n","date":"2020-03-19T00:00:00Z","permalink":"https://rochefort8.github.io/p/%E3%82%BD%E3%83%95%E3%83%88%E3%82%A6%E3%82%A7%E3%82%A2%E9%96%8B%E7%99%BA201%E3%81%AE%E9%89%84%E5%89%87-%E5%8E%9F%E7%90%8610/","title":"ソフトウェア開発201の鉄則 原理10"},{"content":"","date":"2020-03-19T00:00:00Z","permalink":"https://rochefort8.github.io/p/%E3%82%BD%E3%83%95%E3%83%88%E3%82%A6%E3%82%A7%E3%82%A2%E9%96%8B%E7%99%BA201%E3%81%AE%E9%89%84%E5%89%87-%E5%8E%9F%E7%90%86136/","title":"ソフトウェア開発201の鉄則 原理136"},{"content":"要旨 開発者と顧客が全く異なる、相容れない目標を持っていたためにプロジェクトが失敗に終わることがある 関係者間の異なる目標は容易に調整できるようにせよ 「優先度をつける」「要求達成に対する開発者にインセンティブを定義する」「納期が遅れた場合のペナルティーを定義する」と言ったことが、これに当てはまるだろう 解説 開発者と顧客は、目標は異なるのが当たり前。もっというと、複数の開発チームや複数の顧客、管理者と言った、多くの関係者（ステークホルダー）がいるプロジェクトだと、それぞれが持っている望みや目標は、違うものだ。 実際にプロジェクトの成否に関わるほど差分が無い場合も多いが、何れにしても、「違うものだ」ということと、プロジェクトを成功に導くためには、その違いを埋めるために「何かをしなくてはならない」ということは、きちんと認識しておくべきだ。\nじゃ何をしなくては、の一つ目が、一つ前の原理、「原理8:一般:顧客やユーザとよく話し合え」である。\nそして、この原理が、「何を話す必要があるのか」ということになる。\n「見返りを合わせよ」という、なんだかピンとこない表現だが、書いてあることは、要するに、こういうこと。\nそれぞれの要求を「見える化」「定量化」して、その上で「優先度を設けよ」 そうすれば、違いがあっても調整がやりやすくなりますよ その通り。逆にいうと、よく話し合わず、項目を明らかにもせず、優先度もつけないから、「揉める」のである。\n要求や目標が不明確なときは「開発者側から」たたき台を作って提案するのがいい。「我々は要求や達成項目をこう考えていますが、いいですよね」と持ちかけると、主導権を保てるし、何よりも積極的で、気持ちいい。\n","date":"2020-03-18T00:00:00Z","permalink":"https://rochefort8.github.io/p/%E3%82%BD%E3%83%95%E3%83%88%E3%82%A6%E3%82%A7%E3%82%A2%E9%96%8B%E7%99%BA201%E3%81%AE%E9%89%84%E5%89%87-%E5%8E%9F%E7%90%869/","title":"ソフトウェア開発201の鉄則 原理9"},{"content":"","date":"2020-03-17T00:00:00Z","permalink":"https://rochefort8.github.io/p/%E3%82%BD%E3%83%95%E3%83%88%E3%82%A6%E3%82%A7%E3%82%A2%E9%96%8B%E7%99%BA201%E3%81%AE%E9%89%84%E5%89%87-%E5%8E%9F%E7%90%8667/","title":"ソフトウェア開発201の鉄則 原理67"},{"content":"要旨 真のニーズを獲得する唯一の方法は、プロジェクトの最重要人物である顧客とよく話し合うことだ 開発にあたり、早い段階で顧客を巻き込もう 製品のプロトタイプを早い段階で収めるとか、ロールプレイをやるとか、顧客に早い段階でプロジェクトに参加してもらう手段を取ろう 解説 本文には、さらに、\n開発者にとっては、顧客と頻繁に話をせず、誰にも干渉されずに開発を進める方が気楽かもしれないが、そのような進め方をして最終的に出来上がったものを、顧客が本当に臨むだろうか。\nと言っている。\n「開発者の思考」と「顧客の要求」は、話をしなければ、絶対に一致しない。お互いに自分の都合の良いように考えているから。そこを、互いに「妥協」するのが、真のニーズを明らかにし、開発を正しい方向に向かわせるために必要なことである。\n原理7 の「プロトタイプを早い段階で納めよ」は、まさにこの原理に即した行動。他には、身近な開発者に想定顧客になってもらうとか、方法はいくつかある。実行するのは難しいが。\n","date":"2020-03-17T00:00:00Z","permalink":"https://rochefort8.github.io/p/%E3%82%BD%E3%83%95%E3%83%88%E3%82%A6%E3%82%A7%E3%82%A2%E9%96%8B%E7%99%BA201%E3%81%AE%E9%89%84%E5%89%87-%E5%8E%9F%E7%90%868/","title":"ソフトウェア開発201の鉄則 原理8"},{"content":"要旨 真の顧客のニーズを得るための最も効果的な方法は、製品のプロトタイプを提供して使ってもらうことである ウォーターフォールモデルの手法だと、顧客への最初の納品は、最後の工程の、開発資源をほぼ使い切った時に行われる 一方、資源の20%程度が消費されたくらいの段階ででプロトタイプを作成し顧客のフィードバックを得る方法（アジャイル開発とか）もあり この方法だと、顧客のニーズをより明確に知ることもできるし、開発の方向性も早い段階で正しいものにすることができる 解説 百聞は一見に如かず。何らかの手段で顧客に、作る製品を「見える」ようにしましょう、そして使ってもらって得たフィードバックは、最良の要求仕様になり得ますよ、ということ。\n「ウォーターフォールモデル」と「アジャイル開発」は、「二大開発手法」といっていい。\n簡単にいうと、ウォーターフォール（滝）モデルは、上流から下流の工程へ順次移行していき、前の工程には戻らない手法。\n一方、アジャイル（Agile = 素早い）開発は、概ね二週間程度の短い期間で一つの機能を開発・リリースし、その結果をフィードバックして次の期間に向かうことにより、こまめに方向を決めて進めていくやり方。\n今では、アジャイル開発がもてはやされていて、その裏返しとして、ウォーターフォールモデルが批判される傾向にあるが、本来は、開発案件によって使い分けるもの。\nやること、やり方が決まっていれば、ウォーターフォールの方がいい。管理、楽だし。\n一方、目指す目標が漠然としているとか、アジャイルの方がいい。半年もしたら新しい技術が出てきたり、トレンド変わったりして進化が激しい技術開発も、そう。一年経って初めて納品、とかやっていたら、浦島太郎になりますぜ〜\n","date":"2020-03-16T00:00:00Z","permalink":"https://rochefort8.github.io/p/%E3%82%BD%E3%83%95%E3%83%88%E3%82%A6%E3%82%A7%E3%82%A2%E9%96%8B%E7%99%BA201%E3%81%AE%E9%89%84%E5%89%87-%E5%8E%9F%E7%90%867/","title":"ソフトウェア開発201の鉄則 原理7"},{"content":"","date":"2020-03-16T00:00:00Z","permalink":"https://rochefort8.github.io/p/%E3%82%BD%E3%83%95%E3%83%88%E3%82%A6%E3%82%A7%E3%82%A2%E9%96%8B%E7%99%BA201%E3%81%AE%E9%89%84%E5%89%87-%E5%8E%9F%E7%90%8689/","title":"ソフトウェア開発201の鉄則 原理89"},{"content":"要旨 性能が良くないソフトウェアは、良くない部分だけ切り離して新しく設計し直す、といった対応が可能 一方、信頼性が良くないソフトウェアは、その発見が難しくかつ修復するのも困難なものである かつ、信頼性の低いシステムは、致命的な問題を発生させる可能性もあり、タチが悪い 解説 「信頼性」も「性能」な一部の気がしますが。多分、ここでいう「性能」と「信頼性」の違いは、「不具合の再現頻度の高低」ではなかろうか。\n発見できて、原因がわかれば、対応は可能。しかし、数年経って気づいたとか、稀にシステムが停止する、といったものは、再現頻度が低いので、原因解析にも途方も無い時間がかかる。原因がわかれば修正は容易かもしれないが、その確認にも、また時間がかかる。\n開発時には、信頼性に関するテスト（ロングラン・テストとか破壊テストとか）を早い段階で実行しておきなさい、というくらいしか、思いつく対策が、ない。\n","date":"2020-03-15T00:00:00Z","permalink":"https://rochefort8.github.io/p/%E3%82%BD%E3%83%95%E3%83%88%E3%82%A6%E3%82%A7%E3%82%A2%E9%96%8B%E7%99%BA201%E3%81%AE%E9%89%84%E5%89%87-%E5%8E%9F%E7%90%866/","title":"ソフトウェア開発201の鉄則 原理6"},{"content":"","date":"2020-03-15T00:00:00Z","permalink":"https://rochefort8.github.io/p/%E3%82%BD%E3%83%95%E3%83%88%E3%82%A6%E3%82%A7%E3%82%A2%E9%96%8B%E7%99%BA201%E3%81%AE%E9%89%84%E5%89%87-%E5%8E%9F%E7%90%8685/","title":"ソフトウェア開発201の鉄則 原理85"},{"content":"","date":"2020-03-12T00:00:00Z","permalink":"https://rochefort8.github.io/p/%E3%82%BD%E3%83%95%E3%83%88%E3%82%A6%E3%82%A7%E3%82%A2%E9%96%8B%E7%99%BA201%E3%81%AE%E9%89%84%E5%89%87-%E5%8E%9F%E7%90%86127/","title":"ソフトウェア開発201の鉄則 原理127"},{"content":"要旨 この世界、機能しない、バグだらけ、要求を満たさない「出来の悪い」ソフトウェアでいっぱいだが ちゃんと機能し、バグがほぼなく、要件を満たす「高品質な」ソフトウェアは、実現可能である 要件明確化の手法、設計の工夫、優秀な人材の割り当てなど、品質を向上させる実績のあらゆる手法を導入することにより高品質なソフトウェアは実現できる ただ、その実現には高額な費用を要する 解説 キチンとした管理 快適な環境 優秀な人材 まっとうな計画 これらが全部そろって、初めて高品質になる、くらいに考えるといい。\n確かに、世の中のソフトウェアは99%ゴミ、プロジェクトの9割は失敗に終わる、と言ってもいいくらい、ダメな例が溢れている。\n「管理がずさん」「劣悪な環境」「出来悪いエンジニア」「無謀な計画」どれも、経験あるけど、結果は推して知るべし。\n当然、これらを満たすには、お金は、かかる。現実、予算は限られているから、この要素のどこを充実させ、どこを妥協するか、という最適化問題みたいになるだろう。\n","date":"2020-03-12T00:00:00Z","permalink":"https://rochefort8.github.io/p/%E3%82%BD%E3%83%95%E3%83%88%E3%82%A6%E3%82%A7%E3%82%A2%E9%96%8B%E7%99%BA201%E3%81%AE%E9%89%84%E5%89%87-%E5%8E%9F%E7%90%864/","title":"ソフトウェア開発201の鉄則 原理4"},{"content":"要旨 品質に含まれる全てのものは、ソフトウェアに「後付け」することはできない 高品質を達成するのは「開発の初期段階から」努力してやるものだ 使い捨てのプロトタイプを製品化するなぞ、論外だ 解説 201ある原理の中でもトップ10に入るくらい大事な事項で、かつ、トップ10に入るくらい「周知されていない」原理でも、ある。\n要件定義では「機能要件」「非機能要件」というが、その「非機能要件」が品質に当てはまるものである。保守性、信頼性、安全性など\u0026quot;\u0026hellip;bility\u0026quot;と言われているもの、全て、開発途中で「機能要件」のように追加したり変更したりは、基本、「出来ない」。\nなんで、か。\nいろんな考え方があるが、「品質」の各項目は、「機能」のほぼ全てにまたがるものであり、各機能と独立したものではない存在だから、だろう。\n品質を変えたら、多くの機能を見直さなくてはならないだろう。逆に機能を変えたら品質を見直さなけれっばならない。そもそも両立する概念では、ない。\n機能は、見える。品質は、見えない。 単にその差だけで、機能を優先し、品質は後から足すようなことになりがちだ。それが大きな間違い。品質が必要ならば、最初から考慮に入れて各プロセスを進めましょう、ということ。\nアーキテクチャは、「機能要件」でなく「非機能要件」を優先させよ、と聞く。その通りだ。同じ理由。\nエンジニアもマネージャも、この原理は、しかと頭に叩き込んでおこう、そうすれば、今この時代でも炎上プロジェクトの一つとなり得る「使い捨てのプロトタイプを製品化」なんて、絶対に起きえないはずだ。\n","date":"2020-03-12T00:00:00Z","permalink":"https://rochefort8.github.io/p/%E3%82%BD%E3%83%95%E3%83%88%E3%82%A6%E3%82%A7%E3%82%A2%E9%96%8B%E7%99%BA201%E3%81%AE%E9%89%84%E5%89%87-%E5%8E%9F%E7%90%865/","title":"ソフトウェア開発201の鉄則 原理5"},{"content":"","date":"2020-03-11T00:00:00Z","permalink":"https://rochefort8.github.io/p/%E3%82%BD%E3%83%95%E3%83%88%E3%82%A6%E3%82%A7%E3%82%A2%E9%96%8B%E7%99%BA201%E3%81%AE%E9%89%84%E5%89%87-%E5%8E%9F%E7%90%86187/","title":"ソフトウェア開発201の鉄則 原理187"},{"content":"","date":"2020-03-11T00:00:00Z","permalink":"https://rochefort8.github.io/p/%E3%82%BD%E3%83%95%E3%83%88%E3%82%A6%E3%82%A7%E3%82%A2%E9%96%8B%E7%99%BA201%E3%81%AE%E9%89%84%E5%89%87-%E5%8E%9F%E7%90%8638/","title":"ソフトウェア開発201の鉄則 原理38"},{"content":"要旨 「問題を解く」には、解決策を決める（==要求仕様を書く）より前に「問題を特定」しよう 問題はえてして明確にしづらく、人によって、味方によって異なるものだ その捉えた問題ごとに別々の解決策がある 最初に決めた解決策を変更することをためらってはいけない 解説 金言。エンジニアは、いや人は、かな、問題に直面したときに、すぐに直感的に思いついた解決策を取ろうとする。それがたまたま正解なら、それでもいい。ただ、大抵は、そんなに単純では、ない。\n本文記載されているものにに近い例を挙げる。\n「通勤時の電車が激混みで苦痛だ」\n確かにこれは問題。鉄道会社からしたら、その解決法は、「ダイヤを密にする」「車両を増結する」とといったモニになるだろうか。\n一方、通勤者からしたら、同じ時間に通勤するからこのようなことになるわけで、問題は、以下のようにも捉えることができる。\n「同じ時間に通勤する人が多すぎる」 「仕事をするのに通勤が必要なのか？」\nそうなると、解決策は「時差通勤」とか「テレワーク」というものになるだろう。\nいうまでもなく、上記のいくつかの解決先は、どれも異なるもので、かかる費用や効果、実現性は全く違う。\n問題をどこに置き、どれを解決するかを決めるのが、先。その上で要求を決めよう。\nそして、大事なのは。\n一旦決めたからといって「決定」ではない、ということ。柔軟に変更することを躊躇しては、ならない。\n「車両増設はホームの延長工事から必要なので多額の費用がかかる」\n「じゃ通勤者に通勤時間をずらしてもらおうか」\nといった具合に、ベストな解決策==要求は変わっていくものだ。\n","date":"2020-03-11T00:00:00Z","permalink":"https://rochefort8.github.io/p/%E3%82%BD%E3%83%95%E3%83%88%E3%82%A6%E3%82%A7%E3%82%A2%E9%96%8B%E7%99%BA201%E3%81%AE%E9%89%84%E5%89%87-%E5%8E%9F%E7%90%8639/","title":"ソフトウェア開発201の鉄則 原理39"},{"content":"","date":"2020-03-11T00:00:00Z","permalink":"https://rochefort8.github.io/p/%E3%82%BD%E3%83%95%E3%83%88%E3%82%A6%E3%82%A7%E3%82%A2%E9%96%8B%E7%99%BA201%E3%81%AE%E9%89%84%E5%89%87-%E5%8E%9F%E7%90%8666/","title":"ソフトウェア開発201の鉄則 原理66"},{"content":"","date":"2020-03-10T00:00:00Z","permalink":"https://rochefort8.github.io/p/%E3%82%BD%E3%83%95%E3%83%88%E3%82%A6%E3%82%A7%E3%82%A2%E9%96%8B%E7%99%BA201%E3%81%AE%E9%89%84%E5%89%87-%E5%8E%9F%E7%90%86135/","title":"ソフトウェア開発201の鉄則 原理135"},{"content":"","date":"2020-03-10T00:00:00Z","permalink":"https://rochefort8.github.io/p/%E3%82%BD%E3%83%95%E3%83%88%E3%82%A6%E3%82%A7%E3%82%A2%E9%96%8B%E7%99%BA201%E3%81%AE%E9%89%84%E5%89%87-%E5%8E%9F%E7%90%86188/","title":"ソフトウェア開発201の鉄則 原理188"},{"content":"","date":"2020-03-10T00:00:00Z","permalink":"https://rochefort8.github.io/p/%E3%82%BD%E3%83%95%E3%83%88%E3%82%A6%E3%82%A7%E3%82%A2%E9%96%8B%E7%99%BA201%E3%81%AE%E9%89%84%E5%89%87-%E5%8E%9F%E7%90%8691/","title":"ソフトウェア開発201の鉄則 原理91"},{"content":"","date":"2020-03-09T00:00:00Z","permalink":"https://rochefort8.github.io/p/%E3%82%BD%E3%83%95%E3%83%88%E3%82%A6%E3%82%A7%E3%82%A2%E9%96%8B%E7%99%BA201%E3%81%AE%E9%89%84%E5%89%87-%E5%8E%9F%E7%90%86104/","title":"ソフトウェア開発201の鉄則 原理104"},{"content":"要旨 ソフトウェアの品質は、唯一無二の定義は存在しない 品質は、関係者ごとに異なる可能性があるものである そして、それらは、互いに両立しないものとなるジレンマがある なので、その優先度を決めて、すべての関係者にオープンにする必要がある 解説 さらっと読むと、「ま、そうだね、人ごとに違うね」と、さも当然のように思うだろう。が、そのことを理解するのは案外難しい。とにかく、\n「品質の定義が関係者ごとに違って、それらが互いに矛盾する」\nこのようなことがあることを「知っておく」ことが、重要であるように思う。\n例を挙げると、品質に対して求めるものは、こんな感じか。\n開発者 : スマートな設計・実装、さらにバグがほとんどないコード 管理者 : 計画通りのマイルストン達成、発生費用が少ない 顧客 : 正しく動作する、ストレスがなくサクサク動作、使いやすい ここに挙げたもので、すでに矛盾するものが、ある。\n「スマートな設計」と「発生費用」と「使いやすい」。矛盾とまではいかないけど、全関係者を満足させるのは難しいことは、わかるだろう。\nでは、どうしたらいいか。それは、以降に上がる鉄則に、ある。ちょっとだけ先取りすると、こんな感じ。\n要求品質を明らかにするためのプロトタイプをやろう 要求品質は変わっていくものなので、柔軟に変更できるように 顧客とよく話し合え 鉄則1 で「品質第一」といったが、「品質」のなんと難しいことよ。\n","date":"2020-03-09T00:00:00Z","permalink":"https://rochefort8.github.io/p/%E3%82%BD%E3%83%95%E3%83%88%E3%82%A6%E3%82%A7%E3%82%A2%E9%96%8B%E7%99%BA201%E3%81%AE%E9%89%84%E5%89%87-%E5%8E%9F%E7%90%862/","title":"ソフトウェア開発201の鉄則 原理2"},{"content":"要旨 生産性（後述）と品質は明確な相関がある 品質に対する要求が高いと、生産性は落ちる。逆に生産性を追求すると品質は落ちる 高い品質を保つためには、適切な（本文には明確な数値があるが、略）生産性を保つことが必要である 解説 まず、はじめに。\nここでいう生産性（原文も\u0026quot;productivity\u0026quot;）は、単位時間あたりの「作業量」と考えたほうがいい。本文には、一人月あたりのコード行数(KLOCとか) とかFunction Point とか、古典的な生産性の指標が挙がっている。\n要するに、「質と量は相反するものである」と言っているに等しい。\n一般論としてこれは正しいし、たしかにソフトウェア開発にも当てはまるものである。\nただ「生産性」という言葉に、少々引っかかる。生産性の定義は、今は当時とはだいぶ違ったものになっているのではないだろうか。\nソフトウェアで高い成果を挙げるには「コードをたくさん書く」ことが重要だった当時には、「どれだけの量を書けたのか」という指標は大事でだったかもしれない。\n今は、SDK やライブラリ、オープンソースなど、無償で利用できるソフトウェア資産がたくさんある。むしろ、これらを活用して短時間で所望の機能、性能を実現するのが「高い生産性」である。この場合、コード量は、むしろ少ないほうがいい。\nシステムやアーキの決定、その上での設計段階で適切なライブラリやオープンソースを活用、その上でコードを書き、充分な品質を確保する、そういったソフトウェア開発のあらゆる面を「短時間で」満たすことがことが「高い生産性」といえるのではなかろうか。\nそう考えると、「生産性」と「品質」は相反するものでは、ない。「品質も含めた生産性」だろう。\n","date":"2020-03-09T00:00:00Z","permalink":"https://rochefort8.github.io/p/%E3%82%BD%E3%83%95%E3%83%88%E3%82%A6%E3%82%A7%E3%82%A2%E9%96%8B%E7%99%BA201%E3%81%AE%E9%89%84%E5%89%87-%E5%8E%9F%E7%90%863/","title":"ソフトウェア開発201の鉄則 原理3"},{"content":"要旨 品質は何よりも優先されるべきものである 品質は計測可能でなくてはならない 品質を上げる成果に対して報いるようなメカニズムが必須 品質を犠牲にして期限に間に合わせるようなことは絶対にあってはならない。品質が第一の必要条件 解説 「品質第一」これが一番最初に来るのが示唆的と言える。201個の鉄則の中でも最重要なもの、と言っていい。\n「品質」を定めるのは難しい。それは原則2 以降で述べられている。見方によってはなんでも、品質。ここでは、「顧客を最低限満足させるレベルに到達した成果」と言えようか。\n品質の良くないソフトウェアに顧客は「絶対に」満足しない。品質はダメだけど納期には間に合いました。なんてのに何の意味があるのか。\nでは、その品質が顧客を満足させているか、はどうやって判断すればいいのか。そのためには、品質の定義と、その定義された品質が「計測可能」でなくてはならない。「XXXの処理速度が YYY ミリ秒以下であること」「X時間以上連続稼働し不具合が発生しないこと」と言った、いわゆる「数値化」が必要だ、ということ。\nところが、である。ここで第一の原則として言及されている、ということは、その品質が犠牲になることが往々にしてある、ということの証左である。品質を犠牲にして納期に間に合わせる、と言ったことが頻繁に起きる。何で？\nいくつか考えられるうちの一つに、「品質達成の評価が難しい」というのが挙げらえるように思う。「品質」と「納期」どちらの方が単純だろうか。\n品質は、前述のように、定義すること、計測可能にすること自体が難しい。したがって、達成しているかどうかを判断するのは、当然難しい。仮に、「XXXの処理速度が YYY ミリ秒以下であること」と明確だったとしても、その処理速度を長時間にわたってテストしないと、達成度がわからない。\n一方、納期は、カンタン。「3月31日までに納品完了」と決めていれば、それまでに納品されていればOK, そうでなければダメ。小学生でも判断できる。\n要するに、評価する管理者に都合がいいから品質が犠牲になる、というわけ。\n繰り返すが、品質を犠牲にして納期に間に合わせても、顧客は絶対に満足しない。なので、「品質向上に成果に対して報いるメカニズム」が必要となるのである。\n最後にもう一度。\n「品質は全てにおいて最優先の事項」\n","date":"2020-03-08T00:00:00Z","permalink":"https://rochefort8.github.io/p/%E3%82%BD%E3%83%95%E3%83%88%E3%82%A6%E3%82%A7%E3%82%A2%E9%96%8B%E7%99%BA201%E3%81%AE%E9%89%84%E5%89%87-%E5%8E%9F%E7%90%861/","title":"ソフトウェア開発201の鉄則 原理1"},{"content":"","date":"2020-03-08T00:00:00Z","permalink":"https://rochefort8.github.io/p/%E3%82%BD%E3%83%95%E3%83%88%E3%82%A6%E3%82%A7%E3%82%A2%E9%96%8B%E7%99%BA201%E3%81%AE%E9%89%84%E5%89%87-%E5%8E%9F%E7%90%86172/","title":"ソフトウェア開発201の鉄則 原理172"}]