<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
    <channel>
        <title>ソフトウェア開発 201の鉄則 on おぎくんチャンネル</title>
        <link>https://rochefort8.github.io/tags/%E3%82%BD%E3%83%95%E3%83%88%E3%82%A6%E3%82%A7%E3%82%A2%E9%96%8B%E7%99%BA-201%E3%81%AE%E9%89%84%E5%89%87/</link>
        <description>Recent content in ソフトウェア開発 201の鉄則 on おぎくんチャンネル</description>
        <generator>Hugo -- gohugo.io</generator>
        <language>ja</language>
        <copyright>Yuji Ogihara</copyright>
        <lastBuildDate>Sun, 15 Oct 2023 07:28:21 +0900</lastBuildDate><atom:link href="https://rochefort8.github.io/tags/%E3%82%BD%E3%83%95%E3%83%88%E3%82%A6%E3%82%A7%E3%82%A2%E9%96%8B%E7%99%BA-201%E3%81%AE%E9%89%84%E5%89%87/index.xml" rel="self" type="application/rss+xml" /><item>
        <title>「ソフトウェア開発 201の鉄則」の各鉄則を４行でまとめてみる</title>
        <link>https://rochefort8.github.io/p/%E3%82%BD%E3%83%95%E3%83%88%E3%82%A6%E3%82%A7%E3%82%A2%E9%96%8B%E7%99%BA-201%E3%81%AE%E9%89%84%E5%89%87%E3%81%AE%E5%90%84%E9%89%84%E5%89%87%E3%82%92%EF%BC%94%E8%A1%8C%E3%81%A7%E3%81%BE%E3%81%A8%E3%82%81%E3%81%A6%E3%81%BF%E3%82%8B/</link>
        <pubDate>Sun, 15 Oct 2023 07:28:21 +0900</pubDate>
        
        <guid>https://rochefort8.github.io/p/%E3%82%BD%E3%83%95%E3%83%88%E3%82%A6%E3%82%A7%E3%82%A2%E9%96%8B%E7%99%BA-201%E3%81%AE%E9%89%84%E5%89%87%E3%81%AE%E5%90%84%E9%89%84%E5%89%87%E3%82%92%EF%BC%94%E8%A1%8C%E3%81%A7%E3%81%BE%E3%81%A8%E3%82%81%E3%81%A6%E3%81%BF%E3%82%8B/</guid>
        <description>&lt;p&gt;ソフトウェア開発のバイブルと言える名著「ソフトウェア開発　２０１の鉄則」。30年以上のソフトウェア工学の知見をもとに出版。そして、その後著しく進化した現代でも全く色あせないそれぞれの教訓を、現代のソフトウェア開発のトレンドに照らし合わせながら「４行で」言い表してみることにする。&lt;/p&gt;
</description>
        </item>
        <item>
        <title>ソフトウェア開発201の鉄則 原理100</title>
        <link>https://rochefort8.github.io/p/%E3%82%BD%E3%83%95%E3%83%88%E3%82%A6%E3%82%A7%E3%82%A2%E9%96%8B%E7%99%BA201%E3%81%AE%E9%89%84%E5%89%87-%E5%8E%9F%E7%90%86100/</link>
        <pubDate>Wed, 27 May 2020 00:00:00 +0000</pubDate>
        
        <guid>https://rochefort8.github.io/p/%E3%82%BD%E3%83%95%E3%83%88%E3%82%A6%E3%82%A7%E3%82%A2%E9%96%8B%E7%99%BA201%E3%81%AE%E9%89%84%E5%89%87-%E5%8E%9F%E7%90%86100/</guid>
        <description>&lt;h2 id=&#34;要旨&#34;&gt;要旨&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;構造化プログラミングは、もともとは、プログラムの正しさをカンタンに確かめることができるように提唱されたものだ&lt;/li&gt;
&lt;li&gt;今では、そのときに定義された条件分岐やサブルーチンなどを使うこと自体が構造化プログラミングと呼ぶようになった&lt;/li&gt;
&lt;li&gt;プログラムをわかりやすくする、という点で、構造化プログラミングは必要だ&lt;/li&gt;
&lt;li&gt;しかし、それは「高品質なプログラミング」の一部の要素であって、十分条件ではない&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;解説&#34;&gt;解説&lt;/h2&gt;
&lt;p&gt;1969 年に、ソフトウェア工学ではしばしば名前の出てくるDikstra さんが提唱したもの。&lt;/p&gt;
&lt;p&gt;元の目的は、プログラムの正確さをより簡単に測るための見やすさ向上、なんですね（知らなかった）。&lt;/p&gt;
&lt;p&gt;そして今では、プログラミングの基本要素となっている。&lt;a class=&#34;link&#34; href=&#34;https://itmanabi.com/structured-objectoriented-prog/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;ここに詳しい&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;この原理で言っているのは、その、構造化プログラミングができたからといって、それが高品質なソフトウェアとては言えない、ということ。&lt;/p&gt;
&lt;p&gt;そりゃそうですね。よくある、&lt;/p&gt;
&lt;p&gt;必要条件だが、十分条件ではない&lt;/p&gt;
&lt;p&gt;という事項の一つ。&lt;/p&gt;
</description>
        </item>
        <item>
        <title>ソフトウェア開発201の鉄則 原理109</title>
        <link>https://rochefort8.github.io/p/%E3%82%BD%E3%83%95%E3%83%88%E3%82%A6%E3%82%A7%E3%82%A2%E9%96%8B%E7%99%BA201%E3%81%AE%E9%89%84%E5%89%87-%E5%8E%9F%E7%90%86109/</link>
        <pubDate>Sun, 24 May 2020 00:00:00 +0000</pubDate>
        
        <guid>https://rochefort8.github.io/p/%E3%82%BD%E3%83%95%E3%83%88%E3%82%A6%E3%82%A7%E3%82%A2%E9%96%8B%E7%99%BA201%E3%81%AE%E9%89%84%E5%89%87-%E5%8E%9F%E7%90%86109/</guid>
        <description>&lt;h2 id=&#34;要旨&#34;&gt;要旨&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;デバッグやリグレッションテスト、確認のための単体テストといったもの以外の、本格的なテストをソフトウェア開発者は自分で行ってはならない&lt;/li&gt;
&lt;li&gt;テストというのは、バグが見つかって欲しくないと願う開発者に対し、バグを見つける、という行為なので、自分で行ったら正しくできるはずもないからだ&lt;/li&gt;
&lt;li&gt;そして、テスト担当者は、発見したバグを皆の前にさらして、開発者の面子を潰すようなことをしてはならない&lt;/li&gt;
&lt;li&gt;テスティングというのは、バグがでないことを期待する開発者に対し、精神的に追い打ちをかけるような仕事であることを開発者もテスターも認識しよう&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;解説&#34;&gt;解説&lt;/h2&gt;
&lt;p&gt;こう書いてあると、そっか、自分じゃやっちゃいけないのか、と思うだろう。&lt;/p&gt;
&lt;p&gt;自分でやるべきテストも、ある。それは、自分が設計・実装した機能が基本たたしく動作するかを確認するための単体テスト、それと、バグを修正した時、本当にちゃんと修正されているか、別のバグを発生させていないか、を確認するリグレッションテスト。&lt;/p&gt;
&lt;p&gt;これは、ソフトウェア開発者が「自分が正しい仕事ができたのか」を確認するためのものなのだから、それは、自分でやろう。&lt;/p&gt;
&lt;p&gt;それ以降の本格的なテスティング、ストレステストとか統合テストとか、ロングランとか。&lt;/p&gt;
&lt;p&gt;テスティングというのは、バグがないことを示すためにやるのでは、「ない」。&lt;/p&gt;
&lt;p&gt;全く逆で、「バグを見つけるために」やるものである。&lt;/p&gt;
&lt;p&gt;一方で、ソフトウェア開発者は、決して、自分が開発したものにバグがあることを望んだりは、しないだろう。&lt;/p&gt;
&lt;p&gt;そのような、自分が作ったものに対して、出てくることを望まないバグを見つける。それがテスティング。&lt;/p&gt;
&lt;p&gt;自分でできるわけが、ない。&lt;/p&gt;
&lt;p&gt;どうしても、自分でやると、甘〜〜くなるだろう。本格的にテストしているようで、どうしても特定の優しい状況を作り出して実行していることが往々にある。&lt;/p&gt;
&lt;p&gt;十分確認した、と自信満々で持ち込んで、テスターに一撃でバグを見つけられた、という経験は、誰しもお持ちだろう。&lt;/p&gt;
&lt;p&gt;「バグがない」というのは、開発者にとって、成果を出した証。&lt;/p&gt;
&lt;p&gt;「バグを見つけた」というのは、テスターにとって、成果を出した証。&lt;/p&gt;
&lt;p&gt;お互いの仕事を尊重して、仲良くやりましょう。&lt;/p&gt;
</description>
        </item>
        <item>
        <title>ソフトウェア開発201の鉄則 原理75</title>
        <link>https://rochefort8.github.io/p/%E3%82%BD%E3%83%95%E3%83%88%E3%82%A6%E3%82%A7%E3%82%A2%E9%96%8B%E7%99%BA201%E3%81%AE%E9%89%84%E5%89%87-%E5%8E%9F%E7%90%8675/</link>
        <pubDate>Sat, 23 May 2020 00:00:00 +0000</pubDate>
        
        <guid>https://rochefort8.github.io/p/%E3%82%BD%E3%83%95%E3%83%88%E3%82%A6%E3%82%A7%E3%82%A2%E9%96%8B%E7%99%BA201%E3%81%AE%E9%89%84%E5%89%87-%E5%8E%9F%E7%90%8675/</guid>
        <description>&lt;h2 id=&#34;要旨&#34;&gt;要旨&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;ソフトウェアで最もコストがかかる工程は、「保守」である&lt;/li&gt;
&lt;li&gt;なので、保守が容易となるように設計をせよ&lt;/li&gt;
&lt;li&gt;その方法に、一般的なものはない&lt;/li&gt;
&lt;li&gt;例えば、基本構造の選択時に、アルゴリズムやコードの選択よりも保守性を重視する、といったことが挙げられる&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;解説&#34;&gt;解説&lt;/h2&gt;
&lt;p&gt;ソフトウェア「以外の」製品、要するにハードウェアは、設計後最も費用がかかるのは、「生産」。なので、ハードウェア設計の際に一番考慮しなくてはならないのは、生産性。&lt;/p&gt;
&lt;p&gt;ソフトウェアの場合、生産にはほとんど費用がかからない場合が多い。その代わり、保守、運用に費用がかかる。なので、ソフトウェア設計の際に一番考慮しなくてはならないのは、保守・運用。&lt;/p&gt;
&lt;p&gt;生存期間が短いプロトタイプはともかく、製品に組み込まれるソフトウェア、サービスを支えるソフトウェアは、出荷・リリースしてからが本番が始まる。&lt;/p&gt;
&lt;p&gt;売れる、流行るものほど、ここから先の保守・運用が長い。一つのプロジェクトでトータルでかかった費用のうち、９割以上が保守・運用というデータもある。&lt;/p&gt;
&lt;p&gt;設計・実装のフェーズで保守・運用のことを最大限に考慮しなくてはならないのは、当然のことなのだ。&lt;/p&gt;
&lt;p&gt;「保守・運用のための設計」は、一意ではない。保守を容易にするには、総合て的なアプローチが必要だ。&lt;/p&gt;
&lt;p&gt;最適な基本構造の選択、アルゴリズム、データ構造の選択。&lt;/p&gt;
&lt;p&gt;「コーディングの原理」にも上がっている鉄則「読みやすい・わかりやすいコード作成」。&lt;/p&gt;
&lt;p&gt;ドキュメントをきちんと残すこと。&lt;/p&gt;
&lt;p&gt;こういった行動の集合体が、保守性を容易にするアプローチだろう。&lt;/p&gt;
</description>
        </item>
        
    </channel>
</rss>
